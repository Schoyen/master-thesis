\chapter{Solver implementations}
    In this chapter we'll discuss various implementation aspects of the \emph{ab
    initio} solvers discussed in \autoref{chap:hf} through \autoref{chap:ci} and
    \autoref{chap:cc}.

    \section{Hartree-Fock}
        \subsection{Self consistent field procedure}

    \section{Configuration interaction}
        As the main goal of this thesis has been to implement coupled-cluster
        solvers, the configuration interaction solver has not been worked at to
        such a large degree.
        We have therefore implemented a ``naÃ¯ve'' configuration interaction
        solver where we create the full Slater determinant space and store it in
        memory.
        From this we also create the full Hamiltonian matrix $\hamilmat$.
        Our implementation thus quickly absorb too much memory and therefore
        limits the number of particles and basis functions that can be explored.
        To improve on the current scheme, an implementation of the \emph{direct
        CI} methods \cite{helgaker-molecular} along with only storing non-zero
        elements in $\hamilmat$ will yield a more powerfull method supporting
        more particles and basis functions.

        \subsection{Constructing the Slater determinant basis}
            We represent the Slater determinants as NumPy-arrays \cite{numpy} of
            bit strings using unsigned integers.
            The default choice is to use \pyth{np.uint64}, i.e., 64-bit unsigned
            integers with room for 64 single-particle states, but other options
            such as 32-bit and 16-bit unsignd integers are available.
            If we have a system with $L > 64$ we add more integers in the array
            thus allowing for an integer mutiple of $64$ single-particle states at
            a time.
            Let $b$ be the number of bits in an integer, then the number of
            integers needed for a single Slater determinant $N_i$ is given by
            \begin{align}
                N_i = \left\lfloor\frac{L}{b}\right\rfloor
                + q,
            \end{align}
            where $q$ is either one or zero by
            \begin{align}
                q = \begin{cases}
                    1 & L \mod b > 0, \\
                    0 & L \mod b = 0,
                \end{cases}
            \end{align}
            where $L \mod b$ is the remainder of the integer division.
            The number of Slater determinants $N_s$ is given by a recursive
            function $N_s(S)$ depending on the order $S$ of the truncation,
            \begin{align}
                N_s(S) = \begin{cases}
                    1, & S = 0, \\
                    N_s(S - 1) \frac{(N - [S - 1])(M - [S - 1])}{S^2}, & S > 0.
                \end{cases}
            \end{align}
            where $N$ is the number of particles, $M = L - N$ is the number of
            virtual states, and we've denoted the order $S$ as an integer where
            $1$ represents singles, $2$ doubles, and so forth.
            This formula counts the number of ways $N$ particles can be
            distributed among $M$ positions moving $S$ particles at a time.
            For a given truncation level, e.g., singles-and-doubles (CISD), the
            number of Slater determinants is then
            \begin{align}
                N_s = N_s(2) + N_s(1) + N_s(0),
            \end{align}
            where $N_s(0) = 1$ counts the reference state.
            In \autoref{tab:num-slater-determinants} we demonstrate how the
            number of Slater determinants increase as a function of truncation
            for a fixed number of particles.
            The storage cost of the Hamiltonian matrix $\hamilmat$ is uncanny
            going from CIS to CISDTQ as the storage increases by $7$ orders of
            magnitude.
            \begin{table}
                \centering
                \caption{In this table we demonstrate how the number of
                Slater determinants $N_s$ increase as a function of truncation
                level for $N = 4$ and $L = 80$.
                We've also included the number of bytes needed to store the
                Slater determinants using \pyth{np.uint64}, i.e., 64-bit
                unsigned integers to represent the determinants, and the size of
                the Hamiltonian matrix in bytes where we assume 128-bit complex
                numbers as elements.
                The storage cost of the Hamiltonian matrix for CIS was
                $\SI{0.001}{\giga\byte}$, which does not show up in the
                designated one decimal point.}
                \renewcommand{\arraystretch}{1.3}
                \begin{tabular}{@{}lrrr@{}}
                    \toprule
                    Truncation & $N_s$ & Determinant storage $[\si{\byte}]$
                    & Hamiltonian storage $[\si{\giga\byte}]$ \\
                    \midrule
                    CIS & $305$ & $2440$ & $0.0$ \\
                    CISD & $17405$ & $139240$ & $4.5$ \\
                    CISDT & $298605$ & $2388840$ & $1328.7$ \\
                    CISDTQ & $1581580$ & $12652640$ & $37273.7$ \\
                    \bottomrule
                \end{tabular}
                \label{tab:num-slater-determinants}
            \end{table}

            In our code we construct the Slater determinant basis by creating
            the reference determinant where we set the $N$ first bits in the
            array of unsigned integers and then create $N_s - 1$ copies of this
            state.
            The setting of a single-particle state in a bit string is done using
            the binary OR command.
            An example of the setting of single-particle states represented as
            bits is shown in \autoref{alg:set-state-68}.
            \begin{algorithm}
                \inputpython{implementation/solvers/determinants.py}{0}{13}
                \caption{An example of how set the single-particle state $68$ in
                a binary state array \pyth{state} using \pyth{np.uint64}
                integers to represent determinants.}
                \label{alg:set-state-68}
            \end{algorithm}
            Other options are to use the binary XOR operation, but whichever one
            is chosen some care must be shown as bugs can arise if the
            single-particle state is already set.
            In the case of the OR operation this does not change the state, but
            the XOR operation will remove the state.
            For this reason we use the XOR operation in order to unset a bit,
            i.e., remove a single-particle state.

            The higher excited determinants are created by exciting the
            reference determinant in a recursive fashion.
            The excitation operator for a single Slater determinant is shown in
            \autoref{alg:excite-state}.
            \begin{algorithm}
                \inputpython{implementation/solvers/determinants.py}{16}{23}
                \caption{Function used to represent a series of excitation
                operators $\hat{X}^{a}_{i}$, neglecting the sign.}
                \label{alg:excite-state}
            \end{algorithm}
            This function excites all single-particle states in the array
            \pyth{o_remove} to the single-particle states in \pyth{v_insert}.
            Note that the Slater determinants are interpreted as being in
            canonical ordering and we ignore the sign handling when creating the
            basis of determinants.
            The signs are thus handled when computing matrix elements.
            To populate the \pyth{o_remove}- and \pyth{v_insert}-arrays, we have
            a function which recursively adds an occupied index into
            \pyth{o_remove} and then proceeds to add all the virtual indices in
            order into \pyth{v_insert}, before calling the excitation function
            defined in \autoref{alg:excite-state}.
            This function is shown in
            \begin{algorithm}
                \inputpython{implementation/solvers/determinants.py}{26}{56}
                \caption{Function creating all excited determinants of a given
                order \pyth{order}.}
                \label{alg:create-excited-states}
            \end{algorithm}

            The entire implementation of the configuration interaction method is
            uniquely defined by the basis of Slater determinants.
            This means that after a truncation order has been chosen and the
            basis of Slater determinants has been constructed, everything that
            follows will be solved in the same manner independently of the
            truncation level.

        \subsection{Constructing the Hamiltonian matrix}
            The arguably most effective first order optimization that can be
            performed for the configuration interaction method is to implement
            the Slater-Condon rules when evaluating matrix elements of operator
            strings, as opposed to brute force evaluation of the action of the
            second quantized operators on a determinant.
            When constructing the Hamiltonian matrix $\hamilmat$ with one- and
            two-body operators, we wish to evaluate the matrix elements
            \begin{align}
                \hamilten_{IJ}
                = \mel{\Phi_{I}}{\hamil}{\Phi_J}
                =
                \oneten^{p}_{q}
                \mel{\Phi_{I}}{\ccr{p}\can{q}}{\Phi_J}
                +
                \frac{1}{4}
                \twoten^{pq}_{rs}
                \mel{\Phi_{I}}{
                    \ccr{p}
                    \ccr{q}
                    \can{r}
                    \can{s}
                }{\Phi_J},
            \end{align}
            using the Slater-Condon rules defined in
            \autoref{lemma:slater-condon-one-body} and
            \autoref{lemma:slater-condon-two-body}.
            Given two Slater determinants $\ket{\slat_I}$ and $\ket{\slat_J}$
            which we represent as two occupation number states $\ket{\vfg{n}}$
            and $\ket{\vfg{m}}$, respectively, we need ways to evaluate the
            following:
            \begin{itemize}
                \item The sign given by
                    \begin{align}
                        (\Gamma_{-})^{\vfg{n}}_{p}
                        = \prod_{i = 1}^{p - 1}(-1)^{n_i},
                    \end{align}
                    as defined in \autoref{def:creation_1}.
                \item The Kronecker-Delta $\delta_{p \in \vfg{n}}$ checking if
                    the single-particle state $p$ is an occupied state in
                    $\ket{\vfg{n}}$.
                \item The difference $\abs{\vfg{n} - \vfg{m}}$, between the two
                    determinants $\ket{\vfg{n}}$ and $\ket{\vfg{m}}$.
                \item The position of a set bit to a single-particle index $p$
                    in order to find the correct matrix elements in
                    $\oneten^{p}_{q}$ and $\twoten^{pq}_{rs}$.
            \end{itemize}
            For the sign calculation we use the product for the phase
            $(\Gamma_{-})^{\vfg{n}}_i$ defined in \autoref{def:creation_1} by
            counting the number of set bits $k$ at positions below $i$, and
            computing $(-1)^k$.
            An implementation of this sign calculation is shown in
            \autoref{alg:gamma-phase}.
            \begin{algorithm}
                \inputpython{implementation/solvers/determinants.py}{59}{72}
                \caption{Function computing the sign of the action of a creation
                or annihilation operator for index \pyth{p} on a determinant
                \pyth{state}.
                This is the binary implementation of the phase defined in
                \autoref{def:creation_1}.}
                \label{alg:gamma-phase}
            \end{algorithm}
            The implementation of the Kronecker-Delta is shown in
            \autoref{alg:kronecker-delta}.
            \begin{algorithm}
                \inputpython{implementation/solvers/determinants.py}{75}{81}
                \caption{Implementation of the Kronecker-Delta $\delta_{p \in
                \vfg{n}}$.}
                \label{alg:kronecker-delta}
            \end{algorithm}
            To compute the difference between the two determinants we start by
            using the XOR operation to find the specific bits that are set in
            either $\vfg{n}$ or $\vfg{m}$, but not both.
            Next, we count the number of set bits in this difference state.
            The counting of set bits in an integer is a topic which has been
            explored in some depth in the field of computer science and has led
            to some very efficient algorithms.
            We use the population count algorithm \cite{wiki:popcount} shown in
            \autoref{alg:popcount_64}.
            \begin{algorithm}
                \inputpython{implementation/solvers/determinants.py}{84}{96}
                \caption{Implementation of the popcount algorithm for 64-bit
                integers.}
                \label{alg:popcount_64}
            \end{algorithm}
            Now, counting the number of set bits in the difference-state from
            $\ket{\vfg{n}} \text{XOR} \ket{\vfg{m}}$ yields the difference
            $\abs{\vfg{n} - \vfg{m}}$.
            The function in \autoref{alg:state-diff} computes the difference
            between two determinants.
            \begin{algorithm}
                \inputpython{implementation/solvers/determinants.py}{99}{107}
                \caption{Function counting the difference in the number of
                single-particle states in two Slater determinants.}
                \label{alg:state-diff}
            \end{algorithm}
            % TODO: Describe how to compute the bit position to index.

        \subsection{Diagonalization}
            Having constructed the full Hamiltonian matrix $\hamilmat \in
            \mathbb{C}^{N_s \times N_s}$ the next step is to diagonalize the
            matrix in order to get the eigenenergies $\vfg{\energy} = \diag(E_1,
            \dots, E_{N_s})$ and the eigenvectors, i.e., the coefficients for
            the eigenstates, $\vfg{C} \in \mathbb{C}^{N_s \times N_s}$.
            As stated in \autoref{chap:ci}, we restrict our attention to
            orthonormal single-particle states and we therefore need to solve
            the eigenvalue equation
            \begin{align}
                \hamilmat\vfg{C} = \vfg{E}\vfg{C}.
            \end{align}
            The Hamiltonian matrix is Hermitian and we can therefore use the
            function \pyth{np.linalg.eigh} \cite{numpy}, which uses the
            LAPACK-routines \cite{laug} \pyth{_syevd} and \pyth{_heevd} for
            symmetrc and Hermitian matrices respectively, to solve the
            eigenvalue equation.
            This will yield the full spectrum of $\hamilmat$ and will often
            prove a limiting factor in terms of computational complexity as the
            number of FLOPS required to solve this equation scales as
            $\mathcal{O}(N_s^3)$.

            As an alternative to the full spectrum we can use a sparse
            eigenvalue solver.
            We use the function \pyth{scipy.sparse.linalg.eigsh} from SymPy
            \cite{sympy} which is a wrapper around the ARPACK routines SSEUPD
            and DSEUPD \cite{arpack} implementing the Implictly Restarted
            Lanczos Method.
            This lets us specify how many eigenpairs $k$ we wish to compute,
            which is then found iteratively.

        \subsection{Time-evolution}

    \section{Coupled cluster}
