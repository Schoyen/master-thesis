\chapter{Solver implementations}
    In this chapter we'll discuss various implementation aspects of the \emph{ab
    initio} solvers discussed in \autoref{chap:hf} through \autoref{chap:ci} and
    \autoref{chap:cc}.

    \section{Solving the Hartree-Fock equations in a basis}
        Having found the canonical Hartree-Fock equations, we are interested
        in utilizing the method in order to find molecular orbitals
        $\brac{\ket{\phi_p}}_{p = 1}^{L}$ serving as an improvement to our
        known atomic orbital basis $\brac{\ket{\chi_{\alpha}}}_{\alpha =
        1}^{K}$.
        We will in the following demonstrate three different procedures that
        lets us find the molecular orbitals.
        These procedures are related to the restrictions put on the
        spin-orbitals as discussed in
        \autoref{subsec:restrictions-on-spin-orbitals}.
        In fact, each procedure provides a way to choose which restriction we
        want on our molecular orbitals.
        First we'll discuss a general Hartree-Fock method which puts no
        restrictions on the molecular orbitals.
        This method leads to general spin-orbitals as shown in
        \autoref{eq:general-spin-orbital}.
        The second method is known as the \emph{restricted Hartree-Fock} method
        as it assumes restricted spin-orbitals.
        This leads to molecular orbitals that are restricted spin-orbitals as
        shown in \autoref{eq:restricted-spin-orbital}.
        Finally, we'll demonstrate the \emph{unrestricted Hartree-Fock method}
        yielding unrestricted spin-orbitals for the molecular orbitals as
        shown in \autoref{eq:unrestricted-spin-orbital}.

        \subsection{Hartree-Fock with general spin-orbitals}
            Given an atomic orbital basis, e.g., harmonic oscillator basis,
            $\brac{\ket{\chi_{\alpha}}}_{\alpha = 1}^{K}$ we wish to find an
            orthonomal basis of molecular orbitals $\brac{\ket{\phi_{p}}}_{p =
            1}^{L}$ satisfying the canonical Hartree-Fock equations.
            We can transform from the known atomic orbital basis to the unknown
            molecular orbital basis by
            \begin{align}
                \ket{\phi_p} = C_{\alpha p}\ket{\chi_{\alpha}},
            \end{align}
            where $\vfg{C} \in \mathbb{C}^{K\times L}$ is now our unknown
            coefficient matrix.
            The orthonormality condition of the molecular orbitals can no be
            formulated as
            \begin{align}
                \braket{\phi_p}{\phi_q}
                &= C^{*}_{\alpha p} C_{\beta q}
                \braket{\chi_{\alpha}}{\chi_{\beta}}
                = C^{*}_{\alpha p} \overlapten_{\alpha \beta}
                C_{\beta q}
                = \delta_{pq},
            \end{align}
            where we've introduced the overlap matrix $\overlapmat$ with
            elements
            \begin{align}
                \braket{\chi_{\alpha}}{\chi_{\beta}} = \overlapten_{\alpha\beta}.
            \end{align}
            By left-projecting with a state from our atomic orbital basis onto
            the canonical Hartree-Fock equations, we can create a set of
            equations in order to find the coefficients.
            \begin{gather}
                \mel{\chi_{\alpha}}{\fock}{\phi_q}
                = \epsilon_{q} \braket{\chi_{\alpha}}{\phi_q}
                \\
                \implies
                \mel{\chi_{\alpha}}{\fock}{\chi_{\beta}} C_{\beta q}
                = \epsilon_q C_{\beta q} \overlapten_{\alpha \beta}.
            \end{gather}
            We denote the matrix elements of the Fock operator in the atomic
            orbital basis by
            \begin{align}
                \mel{\chi_{\alpha}}{\fock}{\chi_{\beta}}
                \equiv \fockten_{\alpha \beta}.
            \end{align}
            In the case of an orthonormal basis of atomic orbitals, the overlap
            matrix $\overlapmat \in \mathbb{C}^{K \times K}$ reduces to the identity
            matrix.
            The projected Hartree-Fock equations can then be written
            \begin{gather}
                \fockten_{\alpha\beta} C_{\beta q}
                = \overlapten_{\alpha \beta} C_{\beta q} \epsilon_{q}
                \\
                \implies
                \fockmat \vfg{C} = \overlapmat \vfg{C} \vfg{\epsilon},
                \label{eq:roothan-hall-general}
            \end{gather}
            where $\fockmat \in \mathbb{C}^{K \times K}$ is the \emph{Fock
            matrix} with elements from the atomic orbital basis on the Fock
            operator.
            The diagonal matrix $\vfg{\epsilon} = \diag(\epsilon_1, \dots,
            \epsilon_L)$ is the matrix with the eigenenergies from the canonical
            Hartree-Fock equation.
            The equation in \autoref{eq:roothan-hall-general} is known as the
            \emph{Roothan-Hall} equations \cite{roothan, hall}.
            They constitute a formulation of the integro-differential equations
            that are the canonical Hartree-Fock equations to a generalized
            eigenvalue equation formulated as matrices.
            An important point to note is that the Fock operator is an operator
            that includes the molecular orbitals which are dependent on the
            coefficient matrix $\vfg{C}$.
            That is,
            \begin{align}
                \fockten_{\alpha\beta}
                &= \mel{\chi_{\alpha}}{\fock}{\chi_{\beta}}
                = \mel{\chi_{\alpha}}{\onehamil}{\chi_{\beta}}
                +
                \mel{\chi_{\alpha}\phi_j}{\twohamil}{\chi_{\beta}\phi_j}_{AS},
            \end{align}
            where $j$ only sums over the $N$ occupied indices in the ground state
            Slater determinant.
            We see that only the antisymmetric two-body elements depends on the
            coefficient matrix.
            Formulating the elements in terms of the known atomic orbitals and
            the coefficient matrix we get
            \begin{align}
                \mel{\chi_{\alpha}\phi_j}{\twohamil}{\chi_{\beta}\phi_j}
                &=
                C^{*}_{\gamma j} C_{\delta j}
                \mel{\chi_{\alpha}\chi_{\gamma}}{\twohamil}{\chi_{\beta}\chi_{\delta}},
                \\
                \mel{\chi_{\alpha}\phi_j}{\twohamil}{\phi_j\chi_{\beta}}
                &=
                C^{*}_{\gamma j} C_{\delta j}
                \mel{\chi_{\alpha}\chi_{\gamma}}{\twohamil}{\chi_{\delta}\chi_{\beta}}.
            \end{align}
            Introducing the density matrix of the occupied orbitals
            \begin{align}
                D_{\delta\gamma} \equiv
                C^{*}_{\gamma j} C_{\delta j},
            \end{align}
            where it is important to note the ordering of the indices.
            We can then write the matrix elements of the Fock operator in terms
            of the atomic orbitals and the density matrix as
            \begin{align}
                \fockten_{\alpha\beta}
                &= \mel{\chi_{\alpha}}{\onehamil}{\chi_{\beta}}
                +
                D_{\delta\gamma}
                \mel{\chi_{\alpha}\chi_{\gamma}}{\twohamil}{\chi_{\beta}\chi_{\delta}}_{AS}.
            \end{align}
            % TODO: Describe the SCF-procedure
            % TODO: Describe how to handle non-orthogonal atomic orbitals

            Having found the coefficients from the self-consistent field
            iterations and therefore the molecular orbitals and the ground state
            in the Hartree-Fock regime, we are at liberty to compute various
            observables.

            \subsubsection{General Hartree-Fock energy}
                The Hartree-Fock energy can be found by inserting the expansion
                of the molecular orbitals in the energy functional from
                \autoref{eq:energy_func_hf}.
                \begin{align}
                    \energy
                    &= \bra{\phi_i}\onehamil\ket{\phi_i}
                    + \half\bra{\phi_i\phi_j}\twohamil\ket{\phi_i\phi_j}_{AS}
                    \\
                    &=
                    C^{*}_{\alpha i} C_{\beta i}
                    \bra{\chi_{\alpha}}\onehamil\ket{\chi_{\beta}}
                    + \half
                    C^{*}_{\alpha i} C_{\gamma i}
                    C^{*}_{\beta j} C_{\delta j}
                    \bra{\chi_{\alpha}\chi_{\beta}}\twohamil
                    \ket{\chi_{\gamma}\chi_{\delta}}_{AS}
                    \\
                    &=
                    D^{\beta}_{\alpha} \oneten^{\alpha}_{\beta}
                    + \half
                    D^{\gamma}_{\alpha} D^{\delta}_{\beta}
                    \twoten^{\alpha \beta}_{\gamma \delta}.
                    \label{eq:general-hartree-fock-energy}
                \end{align}

            \subsubsection{General Hartree-Fock one-body density matrix}
                Due to the orthonormality of the molecular orbitals, the
                one-body density matrix is particularly comfortable to compute.
                \begin{align}
                    \densityten^{q}_{p}
                    = \braslat
                    \ccr{q}
                    \can{p}
                    \ketslat
                    = \delta_{p \in o}\delta_{pq},
                \end{align}
                where we have labelled the set of occupied indices in the Slater
                determinants by $o = \brac{1, \dots N}$.
                We can represent the one-body density matrix as a block matrix
                by
                \begin{align}
                    \vfg{\densityten}
                    = \begin{pmatrix}
                        \1_{N \times N} & \vfg{0}_{N \times M} \\
                        \vfg{0}_{M \times N} & \vfg{0}_{M \times M}
                    \end{pmatrix},
                \end{align}
                where $M = L - N$, i.e., the number of virtual basis states.

        \subsection{The restricted Hartree-Fock method}
            In the restricted Hartree-Fock method we make the assumption that
            each spin-direction is doubly occupied by an orbital.
            This can be a valid assumption if the Hamiltonian is
            spin-independent\footnote{%
                We write \emph{can} as there are situations where the
                Hamiltonian is spin-independent, but subject to conditions where
                the spin-symmetry of the restricted spin-orbitals break.
                % TODO: This needs to be explained properly
            }.
            To be even more specific, we will look at the \emph{closed-shell
            restricted Hartree-Fock} method, i.e., each spin-orbital \emph{must}
            be doubly occupied and each energy shell must be completely filled.
            This yields the spin-restricted spin-orbitals from
            \autoref{eq:restricted-spin-orbital}.
            For $L$ basis functions, we then get $L/2$ orbitals, where $L$ must
            be an even number.
            We label the states by
            \begin{align}
                \phi_{P}(x) = \varphi_p(\vf{r}) \sigma(m_s)
                \implies
                \ket{\phi_P} = \ket{\varphi_p\sigma},
            \end{align}
            where $P \in \brac{1, \dots, L}$ and $p \in \brac{1, \dots, L / 2}$.
            That is, we use capital letters to refer to composite indices and
            lowercase letters for the orbitals.
            We write the ground state Slater determinant as
            \begin{align}
                \ketslat = \ket{\phi_1 \phi_2 \dots \phi_{L - 1} \phi_L}
                = \ket{
                    (\varphi_1 \alpha)
                    (\varphi_1 \beta)
                    \dots
                    (\varphi_{L / 2} \alpha)
                    (\varphi_{L / 2}\beta)
                }.
            \end{align}
            The restricted molecular orbitals are orthonormal.
            As a consequence both the spin basis functions and the orbitals are
            orthonormal.
            \begin{align}
                \braket{\phi_P}{\phi_Q}
                = \braket{\sigma}{\tau}
                \braket{\varphi_p}{\varphi_q}
                = \delta_{\sigma \tau}
                \delta_{pq}
                = \delta_{PQ}.
            \end{align}
            We now insert the restricted spin-orbitals into the canonical
            Hartree-Fock equation.
            \begin{align}
                \fock\ket{\phi_P} = \epsilon_P\ket{\phi_P}
                \implies
                \fock\ket{\varphi_p\sigma}
                = \epsilon_P\ket{\varphi_p\sigma}.
            \end{align}
            By projecting onto another spin-orbital we demonstrate how we can
            construct the Fock matrix elements when the Hamiltonian is
            spin-independent.
            \begin{align}
                \bra{\phi_P}\fock\ket{\phi_Q}
                = \bra{\phi_P}\onehamil\ket{\phi_Q}
                + \bra{\phi_P\phi_J}\twohamil\ket{\phi_Q\phi_J}_{AS}.
                \label{eq:mo-fock-elements}
            \end{align}
            Looking at the one-body and the two-body parts separately we will
            demonstrate how the spin can be integrated out of the matrix
            elements.
            \begin{align}
                \bra{\phi_P}\onehamil\ket{\phi_Q}
                &= \braket{\sigma}{\tau}\bra{\varphi_p}\onehamil\ket{\varphi_q}
                = \delta_{\sigma\tau}\bra{\varphi_p}\onehamil\ket{\varphi_q}.
            \end{align}
            We split up the antisymmetric elements into its constituent parts
            and show the spin-dependence in each explicitly.
            \begin{align}
                \bra{\phi_P\phi_J}\twohamil\ket{\phi_Q\phi_J}
                &= \braket{\sigma}{\tau}\braket{\nu}{\nu}
                \bra{\varphi_p\varphi_j}\twohamil\ket{\varphi_q\varphi_j}
                = 2 \delta_{\sigma\tau}
                \bra{\varphi_p\varphi_j}\twohamil\ket{\varphi_q\varphi_j},
            \end{align}
            where we've summed over the spin-dependence $\ket{\nu}$ from the two
            occupied orbitals in the two-body elements.
            That is,
            \begin{align}
                \braket{\nu}{\nu} = \delta_{\nu\nu} = 2.
            \end{align}
            For the second integral in the antisymmetric two body elements we
            get
            \begin{align}
                \bra{\phi_P\phi_J}\twohamil\ket{\phi_J\phi_Q}
                &= \braket{\sigma}{\nu}\braket{\nu}{\tau}
                \bra{\varphi_p\varphi_j}\twohamil\ket{\varphi_j\varphi_q}
                = \delta_{\sigma\tau}
                \bra{\varphi_p\varphi_j}\twohamil\ket{\varphi_j\varphi_q},
            \end{align}
            where we've used the completness relation for the spin of the
            occupied molecular orbitals, viz.
            \begin{align}
                \ket{\nu}\bra{\nu}
                = \1 \in \mathbb{R}^{2 \times 2}.
            \end{align}
            Collecting terms, we get the Fock matrix elements
            \begin{align}
                \bra{\phi_P}\fock\ket{\phi_Q}
                &=
                \delta_{\sigma\tau}
                \para{
                    \bra{\varphi_p}\onehamil\ket{\varphi_q}
                    +
                    2
                    \bra{\varphi_p\varphi_j}\twohamil\ket{\varphi_q\varphi_j}
                    -
                    \bra{\varphi_p\varphi_j}\twohamil\ket{\varphi_j\varphi_q}
                },
            \end{align}
            where we see that the spin-dependence has been removed from the
            orbital integrals.
            We can therefore restrict ourselves to the orbital integrals for the
            Fock matrix elements.
            \begin{align}
                \bra{\varphi_p}\fock\ket{\varphi_q}
                &=
                \bra{\varphi_p}\onehamil\ket{\varphi_q}
                +
                2
                \bra{\varphi_p\varphi_j}\twohamil\ket{\varphi_q\varphi_j}
                -
                \bra{\varphi_p\varphi_j}\twohamil\ket{\varphi_j\varphi_q}.
            \end{align}
            This lets us look for coefficients for the orbitals that are
            independent of the spin.
            \begin{align}
                \ket{\varphi_p} = C_{\alpha p} \ket{\chi_{\alpha}},
            \end{align}
            where $\brac{\ket{\chi_{\alpha}}}_{\alpha = 1}^{K}$ is our basis of
            known atomic orbitals, without spin.
            By projecting the canonical Hartree-Fock equations for the orbitals
            onto the atomic orbitals we will again be left with the Roothan-Hall
            equations as in the case of the general Hartree-Fock method.
            However, the difference between the restricted and the general
            Hartree-Fock methods lies in our calculation of the Fock matrix
            elements in the atomic orbital basis.
            \begin{align}
                \fockten_{\alpha\beta}
                &\equiv \bra{\chi_{\alpha}}\fock\ket{\chi_{\beta}}
                =
                \bra{\chi_{\alpha}}\onehamil\ket{\chi_{\beta}}
                +
                2 \bra{\chi_{\alpha}\varphi_j}
                \twohamil
                \ket{\chi_{\beta}\varphi_j}
                - \bra{\chi_{\alpha}\varphi_j}
                \twohamil
                \ket{\varphi_j\chi_{\beta}}
                \\
                &=
                \bra{\chi_{\alpha}}\onehamil\ket{\chi_{\beta}}
                + 2 C^{*}_{j\gamma} C_{j\delta}
                \bra{\chi_{\alpha}\chi_{\gamma}}
                \twohamil
                \ket{\chi_{\beta}\chi_{\delta}}
                - C^{*}_{j\gamma} C_{j\delta}
                \bra{\chi_{\alpha}\chi_{\gamma}}
                \twohamil
                \ket{\chi_{\delta}\chi_{\beta}}
                \\
                &=
                \bra{\chi_{\alpha}}\onehamil\ket{\chi_{\beta}}
                + D_{\delta\gamma}
                \para{
                    \bra{\chi_{\alpha}\chi_{\gamma}}
                    \twohamil
                    \ket{\chi_{\beta}\chi_{\delta}}
                    -
                    \half
                    \bra{\chi_{\alpha}\chi_{\gamma}}
                    \twohamil
                    \ket{\chi_{\delta}\chi_{\beta}}
                },
                \label{eq:atomic-fock-rhf}
            \end{align}
            where we've introduced the restriced density matrix
            \begin{align}
                D_{\beta \alpha}
                = 2 C^{*}_{\alpha i} C_{\beta i},
            \end{align}
            as the index $i \in \brac{1, \dots, N / 2}$, where $N$ is the number
            of occupied states in the Hartree-Fock Slater determinant.

            By proceeding witht the self-consistent field iterations solving the
            Roothan-Hall equations with \autoref{eq:atomic-fock-rhf} as the
            definition of the Fock matrix elements, we find the orbital
            coefficient matrix $\vfg{C} \in \mathbb{C}^{K \times L/2}$ which we
            use to transform to the restricted molecular orbitals.
            Once transformed, we are at liberty to introduce spin-redundancy to
            open up for more general post Hartree-Fock methods.

            \subsubsection{Restricted Hartree-Fock energy}
                We can compute the ground-state restricted Hartree-Fock energy
                by inserting our expression for the restricted molecular
                orbitals into the energy functional in
                \autoref{eq:energy_func_hf}.
                \begin{align}
                    \energy
                    &= \bra{\Phi}\hamil\ket{\Phi}
                    = \bra{\phi_I}\onehamil\ket{\phi_I}
                    + \half
                    \bra{\phi_I\phi_J}
                    \twohamil
                    \ket{\phi_I\phi_J}_{AS}
                    \\
                    &=
                    \delta_{\sigma\sigma}
                    \bra{\varphi_i}\onehamil\ket{\varphi_i}
                    + \half\para{
                        \delta_{\sigma\sigma}\delta_{\tau\tau}
                        \bra{\varphi_i\varphi_j}
                        \twohamil
                        \ket{\varphi_i\varphi_j}
                        - \delta_{\sigma\tau}\delta_{\tau\sigma}
                        \bra{\varphi_i\varphi_j}
                        \twohamil
                        \ket{\varphi_j\varphi_i}
                    }
                    \\
                    &=
                    D^{\beta}_{\alpha}
                    \oneten^{\alpha}_{\beta}
                    + \half\para{
                        D^{\beta}_{\alpha}
                        D^{\delta}_{\gamma}
                        \twotensym^{\alpha\gamma}_{\beta\delta}
                        - \half
                        D^{\beta}_{\alpha}
                        D^{\delta}_{\gamma}
                        \twotensym^{\alpha\gamma}_{\delta\beta}
                    }
                    \\
                    &=
                    D^{\beta}_{\alpha}
                    \brac{
                        \oneten^{\alpha}_{\beta}
                        + \half D^{\delta}_{\gamma}
                        \para{
                            \twotensym^{\alpha\gamma}_{\beta\delta}
                            - \half
                            \twotensym^{\alpha\gamma}_{\delta\beta}
                        }
                    },
                    %&=
                    %D_{\beta \alpha}
                    %%C^{*}_{\alpha i} C_{\beta i}
                    %\bra{\chi_{\alpha}}\onehamil\ket{\chi_{\beta}}
                    %+ \half\para{
                    %    D_{\gamma\alpha} D_{\delta\beta}
                    %    %C^{*}_{\alpha i} C_{\gamma i}
                    %    %C^{*}_{\beta j} C_{\delta j}
                    %    -
                    %    \half
                    %    D_{\delta\alpha}
                    %    D_{\gamma\beta}
                    %    %C^{*}_{\alpha i} C_{\delta i}
                    %    %C^{*}_{\beta j} C_{\gamma j}
                    %}
                    %\bra{\chi_{\alpha}\chi_{\beta}}
                    %\twohamil
                    %\ket{\chi_{\gamma}\chi_{\delta}}.
                \end{align}
                where we've introduced the notation
                \begin{align}
                    \twotensym^{\alpha\beta}_{\gamma\delta}
                    \equiv \bra{\chi_{\alpha}\chi_{\beta}}
                    \twohamil
                    \ket{\chi_{\gamma}\chi_{\delta}},
                \end{align}
                for the two-body integrals.

        \subsection{The unrestricted Hartree-Fock method}
            The unrestricted Hartree-Fock method allows the molecular orbitals
            to have independent orbitals for each spin-direction.
            Hence, we assume that the molecular orbitals can be described by
            spin-unrestricted spin-orbitals as seen in
            \autoref{eq:unrestricted-spin-orbital}.
            Introducing indices for the different molecular orbitals, we denote
            the spin-unrestricted molecular orbitals by
            \begin{align}
                \phi_P(x)
                &=
                \varphi^{\sigma}_{p}(\vf{r})
                \sigma(m_s)
                \implies
                \ket{\phi_P}
                = \ket{\varphi^{\sigma}_{p}\sigma},
            \end{align}
            where $P \in \brac{1, \dots, L}$, $\sigma \in \brac{\alpha, \beta}$,
            and $p \in \brac{1, \dots, L_{\sigma}}$.
            We have that $L = L_{\alpha} + L_{\beta}$ and we have refrained from
            labelling the lower case orbital indices as they always occur with a
            spin index.
            Note that there is no implicit sum over the label $\sigma$ in the
            orbital $\varphi^{\sigma}_{p}$ and the spin-function $\sigma(m_s)$.
            We can collect the orbitals in two sets
            $\brac{\ket{\varphi^{\sigma}_{p}}}_{p = 1}^{L_{\sigma}}$, one for
            each spin-direction.
            The ground state Slater determinant can then be written
            \begin{align}
                \ketslat
                &=
                \ket{\phi_1 \phi_2 \dots \phi_{N - 1} \phi_N}
                =
                \ket{
                    (\varphi^{\alpha}_{1}\alpha)
                    \dots
                    (\varphi^{\alpha}_{N_{\alpha}}\alpha)
                    (\varphi^{\beta}_{1}\beta)
                    \dots
                    (\varphi^{\beta}_{N_{\beta}}\beta)
                },
            \end{align}
            where $N_{\sigma}$ is the number of particles with spin
            $\sigma(m_s)$.
            The orthonormality of the molecular orbitals is given by
            \begin{align}
                \braket{\phi_P}{\phi_Q}
                &= \delta^{P}_{Q}
                = \braket{\sigma}{\tau}
                \braket{\varphi^{\sigma}_{p}}{\varphi^{\tau}_{q}},
            \end{align}
            where the overlap between two orbitals with differing spin is not
            necessarily zero.
            However, if the two spin-directions are the same, i.e., $\sigma =
            \tau$, we get
            \begin{align}
                \braket{\varphi^{\sigma}_{p}}{\varphi^{\sigma}_{q}}
                = \delta^{p}_{q}.
            \end{align}
            Inserting the unrestricted spin-orbitals into the canonical
            Hartree-Fock equation yields
            \begin{align}
                \fock\ket{\phi_P}
                = \epsilon_P\ket{\phi_P}
                \implies
                \fock\ket{\varphi^{\sigma}_{p}\sigma}
                = \epsilon^{\sigma}_{p}\ket{\varphi^{\sigma}_{p} \sigma},
            \end{align}
            which demonstrates how each spin-component yields a different
            equation as the Fock eigenenergies $\epsilon^{\alpha}_{p}$ is in
            general different from $\epsilon^{\beta}_{p}$.
            By projecting onto another molecular orbital as in
            \autoref{eq:mo-fock-elements} we demonstrate how the spin yields two
            separate Fock matrices, one for each spin-direction.\footnote{%
                Note that this assumes a spin-independent Hamiltonian.
            }
            The one-body elements in the molecular orbital basis is given by
            \begin{align}
                \bra{\phi_P}\onehamil\ket{\phi_Q}
                &= \braket{\sigma}{\tau}
                \bra{\varphi^{\sigma}_{p}}
                \onehamil
                \ket{\varphi^{\tau}_{q}}
                = \delta^{\sigma}_{\tau}
                \bra{\varphi^{\sigma}_{p}}
                \onehamil
                \ket{\varphi^{\tau}_{q}}
            \end{align}
            The two-body elements yield
            \begin{align}
                \bra{\phi_P\phi_J}
                \twohamil
                \ket{\phi_Q\phi_J}
                &=
                \braket{\sigma}{\tau}
                \braket{\rho}{\rho}
                \bra{\varphi^{\sigma}_{p}\varphi^{\rho}_{j}}
                \twohamil
                \ket{\varphi^{\tau}_{q}\varphi^{\rho}_{j}}
                =
                \delta^{\sigma}_{\tau}
                \bra{\varphi^{\sigma}_{p}\varphi^{\rho}_{j}}
                \twohamil
                \ket{\varphi^{\tau}_{q}\varphi^{\rho}_{j}}
                \\
                &=
                \delta^{\sigma}_{\tau}
                \para{
                    \bra{\varphi^{\sigma}_{p}\varphi^{\alpha}_{j}}
                    \twohamil
                    \ket{\varphi^{\tau}_{q}\varphi^{\alpha}_{j}}
                    +
                    \bra{\varphi^{\sigma}_{p}\varphi^{\beta}_{j}}
                    \twohamil
                    \ket{\varphi^{\tau}_{q}\varphi^{\beta}_{j}}
                },
            \end{align}
            where, unlike in the restricted scheme, we get no factor $2$ from
            the Kronecker-Delta $\delta^{\rho}_{\rho}$ as the orbitals in the two
            different spin-directions are unequal.
            We note that this term provides a coupling between the orbitals in
            both spin-directions.
            The last term in the antisymmetric two-body elements is given by
            \begin{align}
                \bra{\phi_P\phi_J}
                \twohamil
                \ket{\phi_J\phi_Q}
                &=
                \braket{\sigma}{\rho}
                \braket{\rho}{\tau}
                \bra{\varphi^{\sigma}_{p}\varphi^{\rho}_{j}}
                \twohamil
                \ket{\varphi^{\rho}_{j}\varphi^{\tau}_{q}}
                =
                \delta^{\sigma}_{\tau}
                \bra{\varphi^{\sigma}_{p}\varphi^{\tau}_{j}}
                \twohamil
                \ket{\varphi^{\sigma}_{j}\varphi^{\tau}_{q}}.
            \end{align}
            Collecting terms we are then left with
            \begin{align}
                \bra{\phi_P}\fock\ket{\phi_Q}
                &=
                \delta^{\sigma}_{\tau}
                \para{
                    \bra{\varphi^{\sigma}_{p}}
                    \onehamil
                    \ket{\varphi^{\tau}_{q}}
                    +
                    \bra{\varphi^{\sigma}_{p}\varphi^{\rho}_{j}}
                    \twohamil
                    \ket{\varphi^{\tau}_{q}\varphi^{\rho}_{j}}
                    -
                    \bra{\varphi^{\sigma}_{p}\varphi^{\tau}_{j}}
                    \twohamil
                    \ket{\varphi^{\sigma}_{j}\varphi^{\tau}_{q}}
                },
            \end{align}
            where we've demonstrated how the spin yields two different Fock
            matrices from the canonical Hartree-Fock equations.
            That is,
            \begin{align}
                \bra{\varphi^{\sigma}_{p}}\fock\ket{\varphi^{\sigma}_{q}}
                &=
                \bra{\varphi^{\sigma}_{p}}
                \onehamil
                \ket{\varphi^{\sigma}_{q}}
                +
                \bra{\varphi^{\sigma}_{p}\varphi^{\rho}_{j}}
                \twohamil
                \ket{\varphi^{\sigma}_{q}\varphi^{\rho}_{j}}
                -
                \bra{\varphi^{\sigma}_{p}\varphi^{\sigma}_{j}}
                \twohamil
                \ket{\varphi^{\sigma}_{j}\varphi^{\sigma}_{q}},
            \end{align}
            We now look for a set of coefficients for the orbitals in each
            spin-direction in terms of our original atomic orbital basis.
            \begin{align}
                \ket{\varphi^{\sigma}_{p}}
                &= C^{\sigma}_{\kappa p} \ket{\chi_{\kappa}},
            \end{align}
            where we use the greek letters $\kappa$, $\lambda$, $\mu$, and $\nu$
            for the atomic orbitals to avoid confusion with the spin-functions
            $\alpha(m_s)$ and $\beta(m_s)$.
            Before we demonstrate how we can generate a set of equations in
            order to find the coefficient matrices $\vfg{C}^{\sigma}$, we
            motivate the spin-labelling of the Fock matrices in the atomic
            orbital basis.
            \begin{align}
                \fockten^{\sigma}_{\kappa\lambda}
                &\equiv
                \bra{\chi_{\kappa}}\fock^{\sigma}\ket{\chi_{\lambda}}
                =
                \oneten_{\kappa\lambda}
                + \bra{\chi_{\kappa}\varphi^{\rho}_{j}}
                \twohamil
                \ket{\chi_{\lambda}\varphi^{\rho}_{j}}
                - \bra{\chi_{\kappa}\varphi^{\sigma}_{j}}
                \twohamil
                \ket{\varphi^{\sigma}_{j}\chi_{\lambda}}
                \\
                &=
                \oneten_{\kappa\lambda}
                +
                (C^{\rho}_{\mu j})^{*}
                C^{\rho}_{\nu j}
                \twotensym^{\kappa\mu}_{\lambda\nu}
                -
                (C^{\sigma}_{\mu j})^{*}
                C^{\sigma}_{\nu j}
                \twotensym^{\kappa\mu}_{\nu\lambda}
                \\
                &=
                \oneten_{\kappa\lambda}
                +
                D^{\rho}_{\nu\mu}
                \twotensym^{\kappa\mu}_{\lambda\nu}
                -
                D^{\sigma}_{\nu\mu}
                \twotensym^{\kappa\mu}_{\nu\lambda},
            \end{align}
            where the density matrix $D^{\rho}_{\nu\mu}$ with the free
            spin-index $\rho$ is summed yielding
            \begin{align}
                D^{\rho}_{\nu\mu}
                = D^{\alpha}_{\nu\mu}
                + D^{\beta}_{\nu\mu},
            \end{align}
            as opposed to the density matrix with the same spin-index as the
            left-hand side, that is, $\sigma$.
            Left-projecting the atomic orbital basis on the canonical
            Hartree-Fock equations acting on an orbital in the unrestriced
            regime yields
            \begin{gather}
                \bra{\chi_{\kappa}}\fock^{\sigma}\ket{\varphi^{\sigma}_{p}}
                = \epsilon^{\sigma}_{p}
                \braket{\chi_{\kappa}}{\varphi^{\sigma}_{p}}
                \\
                \implies
                C^{\sigma}_{\lambda p}
                \bra{\chi_{\kappa}}\fock^{\sigma}\ket{\chi_{\lambda}}
                = C^{\sigma}_{\lambda p} \epsilon^{\sigma}_{p}
                \braket{\chi_{\kappa}}{\chi_{\lambda}}
                \\
                \implies
                \fockten^{\sigma}_{\kappa \lambda}
                C^{\sigma}_{\lambda p}
                =
                \overlapten_{\kappa\lambda}
                C^{\sigma}_{\lambda p}
                \epsilon^{\sigma}_{p}
                \\
                \implies
                \vfg{F}^{\sigma}
                \vfg{C}^{\sigma}
                =
                \overlapmat
                \vfg{C}^{\sigma}
                \vfg{\epsilon}^{\sigma}.
            \end{gather}
            These coupled equations constitute the \emph{Pople-Nesbet
            equations}.
            They resemble the Roothan-Hall equations seen in the two previous
            methods in that they are generalized eigenvalue equations, but now
            we solve two sets of eigenvalue equations simultaneously.

            \subsubsection{The unrestricted Hartree-Fock energy}
                Inserting our expression for the molecular orbitals into the
                energy functional we find the unrestricted Hartree-Fock energy.
                \begin{align}
                    \energy
                    &=
                    \bra{\slat}\hamil\ket{\slat}
                    =
                    \bra{\phi_I}\onehamil\ket{\phi_I}
                    +
                    \half
                    \bra{\phi_I\phi_J}
                    \twohamil
                    \ket{\phi_I\phi_J}_{AS}
                    \\
                    &=
                    \bra{\varphi^{\sigma}_{i}}
                    \onehamil
                    \ket{\varphi^{\sigma}_{i}}
                    + \half\para{
                        \bra{\varphi^{\sigma}_{i}\varphi^{\tau}_{j}}
                        \twohamil
                        \ket{\varphi^{\sigma}_{i}\varphi^{\tau}_{j}}
                        -
                        \bra{\varphi^{\sigma}_{i}\varphi^{\sigma}_{j}}
                        \twohamil
                        \ket{\varphi^{\sigma}_{j}\varphi^{\sigma}_{i}}
                    }
                    \\
                    &=
                    D^{\sigma}_{\beta\alpha}
                    \oneten^{\alpha}_{\beta}
                    + \half
                    D^{\sigma}_{\beta\alpha}
                    D^{\tau}_{\delta\gamma}
                    \twotensym^{\alpha\gamma}_{\beta\delta}
                    - \half
                    D^{\sigma}_{\beta\alpha}
                    D^{\sigma}_{\delta\gamma}
                    \twotensym^{\alpha\gamma}_{\delta\beta},
                \end{align}
                where we've carried out the spin-sums implicitly and skipped the
                step where we show the coefficient matrices that go into the
                density matrices.

        \subsection{Self consistent field procedure}

    \section{Configuration interaction}
        As the main goal of this thesis has been to implement coupled-cluster
        solvers, the configuration interaction solver has not been worked at to
        such a large degree.
        We have therefore implemented a ``naïve'' configuration interaction
        solver where we create the full Slater determinant space and store it in
        memory.
        From this we also create the full Hamiltonian matrix $\hamilmat$.
        Our implementation thus quickly absorb too much memory and therefore
        limits the number of particles and basis functions that can be explored.
        To improve on the current scheme, an implementation of the \emph{direct
        CI} methods \cite{helgaker-molecular} along with only storing non-zero
        elements in $\hamilmat$ will yield a more powerfull method supporting
        more particles and basis functions.

        \subsection{Constructing the Slater determinant basis}
            We represent the Slater determinants as NumPy-arrays \cite{numpy} of
            bit strings using unsigned integers.
            The default choice is to use \pyth{np.uint64}, i.e., 64-bit unsigned
            integers with room for 64 single-particle states, but other options
            such as 32-bit and 16-bit unsignd integers are available.
            If we have a system with $L > 64$ we add more integers in the array
            thus allowing for an integer mutiple of $64$ single-particle states at
            a time.
            Let $b$ be the number of bits in an integer, then the number of
            integers needed for a single Slater determinant $N_i$ is given by
            \begin{align}
                N_i = \left\lfloor\frac{L}{b}\right\rfloor
                + q,
            \end{align}
            where $q$ is either one or zero by
            \begin{align}
                q = \begin{cases}
                    1 & L \mod b > 0, \\
                    0 & L \mod b = 0,
                \end{cases}
            \end{align}
            where $L \mod b$ is the remainder of the integer division.
            The number of Slater determinants $N_s$ is given by a recursive
            function $N_s(S)$ depending on the order $S$ of the truncation,
            \begin{align}
                N_s(S) = \begin{cases}
                    1, & S = 0, \\
                    N_s(S - 1) \frac{(N - [S - 1])(M - [S - 1])}{S^2}, & S > 0.
                \end{cases}
            \end{align}
            where $N$ is the number of particles, $M = L - N$ is the number of
            virtual states, and we've denoted the order $S$ as an integer where
            $1$ represents singles, $2$ doubles, and so forth.
            This formula counts the number of ways $N$ particles can be
            distributed among $M$ positions moving $S$ particles at a time.
            For a given truncation level, e.g., singles-and-doubles (CISD), the
            number of Slater determinants is then
            \begin{align}
                N_s = N_s(2) + N_s(1) + N_s(0),
            \end{align}
            where $N_s(0) = 1$ counts the reference state.
            In \autoref{tab:num-slater-determinants} we demonstrate how the
            number of Slater determinants increase as a function of truncation
            for a fixed number of particles.
            The storage cost of the Hamiltonian matrix $\hamilmat$ is uncanny
            going from CIS to CISDTQ as the storage increases by $7$ orders of
            magnitude.
            \begin{table}
                \centering
                \caption{In this table we demonstrate how the number of
                Slater determinants $N_s$ increase as a function of truncation
                level for $N = 4$ and $L = 80$.
                We've also included the number of bytes needed to store the
                Slater determinants using \pyth{np.uint64}, i.e., 64-bit
                unsigned integers to represent the determinants, and the size of
                the Hamiltonian matrix in bytes where we assume 128-bit complex
                numbers as elements.
                The storage cost of the Hamiltonian matrix for CIS was
                $\SI{0.001}{\giga\byte}$, which does not show up in the
                designated one decimal point.}
                \renewcommand{\arraystretch}{1.3}
                \begin{tabular}{@{}lrrr@{}}
                    \toprule
                    Truncation & $N_s$ & Determinant storage $[\si{\byte}]$
                    & Hamiltonian storage $[\si{\giga\byte}]$ \\
                    \midrule
                    CIS & $305$ & $2440$ & $0.0$ \\
                    CISD & $17405$ & $139240$ & $4.5$ \\
                    CISDT & $298605$ & $2388840$ & $1328.7$ \\
                    CISDTQ & $1581580$ & $12652640$ & $37273.7$ \\
                    \bottomrule
                \end{tabular}
                \label{tab:num-slater-determinants}
            \end{table}

            In our code we construct the Slater determinant basis by creating
            the reference determinant where we set the $N$ first bits in the
            array of unsigned integers and then create $N_s - 1$ copies of this
            state.
            The setting of a single-particle state in a bit string is done using
            the binary OR command.
            An example of the setting of single-particle states represented as
            bits is shown in \autoref{alg:set-state-68}.
            \begin{algorithm}
                \inputpython{implementation/solvers/determinants.py}{0}{13}
                \caption{An example of how set the single-particle state $68$ in
                a binary state array \pyth{state} using \pyth{np.uint64}
                integers to represent determinants.}
                \label{alg:set-state-68}
            \end{algorithm}
            Other options are to use the binary XOR operation, but whichever one
            is chosen some care must be shown as bugs can arise if the
            single-particle state is already set.
            In the case of the OR operation this does not change the state, but
            the XOR operation will remove the state.
            For this reason we use the XOR operation in order to unset a bit,
            i.e., remove a single-particle state.

            The higher excited determinants are created by exciting the
            reference determinant in a recursive fashion.
            The excitation operator for a single Slater determinant is shown in
            \autoref{alg:excite-state}.
            \begin{algorithm}
                \inputpython{implementation/solvers/determinants.py}{16}{23}
                \caption{Function used to represent a series of excitation
                operators $\hat{X}^{a}_{i}$, neglecting the sign.}
                \label{alg:excite-state}
            \end{algorithm}
            This function excites all single-particle states in the array
            \pyth{o_remove} to the single-particle states in \pyth{v_insert}.
            Note that the Slater determinants are interpreted as being in
            canonical ordering and we ignore the sign handling when creating the
            basis of determinants.
            The signs are thus handled when computing matrix elements.
            To populate the \pyth{o_remove}- and \pyth{v_insert}-arrays, we have
            a function which recursively adds an occupied index into
            \pyth{o_remove} and then proceeds to add all the virtual indices in
            order into \pyth{v_insert}, before calling the excitation function
            defined in \autoref{alg:excite-state}.
            This function is shown in
            \begin{algorithm}
                \inputpython{implementation/solvers/determinants.py}{26}{56}
                \caption{Function creating all excited determinants of a given
                order \pyth{order}.}
                \label{alg:create-excited-states}
            \end{algorithm}

            The entire implementation of the configuration interaction method is
            uniquely defined by the basis of Slater determinants.
            This means that after a truncation order has been chosen and the
            basis of Slater determinants has been constructed, everything that
            follows will be solved in the same manner independently of the
            truncation level.

        \subsection{Constructing the Hamiltonian matrix}
            The arguably most effective first order optimization that can be
            performed for the configuration interaction method is to implement
            the Slater-Condon rules when evaluating matrix elements of operator
            strings, as opposed to brute force evaluation of the action of the
            second quantized operators on a determinant.
            When constructing the Hamiltonian matrix $\hamilmat$ with one- and
            two-body operators, we wish to evaluate the matrix elements
            \begin{align}
                \hamilten_{IJ}
                = \mel{\Phi_{I}}{\hamil}{\Phi_J}
                =
                \oneten^{p}_{q}
                \mel{\Phi_{I}}{\ccr{p}\can{q}}{\Phi_J}
                +
                \frac{1}{4}
                \twoten^{pq}_{rs}
                \mel{\Phi_{I}}{
                    \ccr{p}
                    \ccr{q}
                    \can{r}
                    \can{s}
                }{\Phi_J},
            \end{align}
            using the Slater-Condon rules defined in
            \autoref{lemma:slater-condon-one-body} and
            \autoref{lemma:slater-condon-two-body}.
            Given two Slater determinants $\ket{\slat_I}$ and $\ket{\slat_J}$
            which we represent as two occupation number states $\ket{\vfg{n}}$
            and $\ket{\vfg{m}}$, respectively, we need ways to evaluate the
            following:
            \begin{itemize}
                \item The sign given by
                    \begin{align}
                        (\Gamma_{-})^{\vfg{n}}_{p}
                        = \prod_{i = 1}^{p - 1}(-1)^{n_i},
                    \end{align}
                    as defined in \autoref{def:creation_1}.
                \item The Kronecker-Delta $\delta_{p \in \vfg{n}}$ checking if
                    the single-particle state $p$ is an occupied state in
                    $\ket{\vfg{n}}$.
                \item The difference $\abs{\vfg{n} - \vfg{m}}$, between the two
                    determinants $\ket{\vfg{n}}$ and $\ket{\vfg{m}}$.
                \item The position of a set bit to a single-particle index $p$
                    in order to find the correct matrix elements in
                    $\oneten^{p}_{q}$ and $\twoten^{pq}_{rs}$.
            \end{itemize}
            For the sign calculation we use the product for the phase
            $(\Gamma_{-})^{\vfg{n}}_i$ defined in \autoref{def:creation_1} by
            counting the number of set bits $k$ at positions below $i$, and
            computing $(-1)^k$.
            An implementation of this sign calculation is shown in
            \autoref{alg:gamma-phase}.
            \begin{algorithm}
                \inputpython{implementation/solvers/determinants.py}{59}{72}
                \caption{Function computing the sign of the action of a creation
                or annihilation operator for index \pyth{p} on a determinant
                \pyth{state}.
                This is the binary implementation of the phase defined in
                \autoref{def:creation_1}.}
                \label{alg:gamma-phase}
            \end{algorithm}
            The implementation of the Kronecker-Delta is shown in
            \autoref{alg:kronecker-delta}.
            \begin{algorithm}
                \inputpython{implementation/solvers/determinants.py}{75}{81}
                \caption{Implementation of the Kronecker-Delta $\delta_{p \in
                \vfg{n}}$.}
                \label{alg:kronecker-delta}
            \end{algorithm}
            To compute the difference between the two determinants we start by
            using the XOR operation to find the specific bits that are set in
            either $\vfg{n}$ or $\vfg{m}$, but not both.
            Next, we count the number of set bits in this difference state.
            The counting of set bits in an integer is a topic which has been
            explored in some depth in the field of computer science and has led
            to some very efficient algorithms.
            We use the population count algorithm \cite{wiki:popcount} shown in
            \autoref{alg:popcount_64}.
            \begin{algorithm}
                \inputpython{implementation/solvers/determinants.py}{84}{97}
                \caption{Implementation of the popcount algorithm for 64-bit
                integers.}
                \label{alg:popcount_64}
            \end{algorithm}
            Now, counting the number of set bits in the difference-state from
            $\ket{\vfg{n}} \text{XOR} \ket{\vfg{m}}$ yields the difference
            $\abs{\vfg{n} - \vfg{m}}$.
            The function in \autoref{alg:state-diff} computes the difference
            between two determinants.
            \begin{algorithm}
                \inputpython{implementation/solvers/determinants.py}{100}{108}
                \caption{Function counting the difference in the number of
                single-particle states in two Slater determinants.}
                \label{alg:state-diff}
            \end{algorithm}
            To compute the index of a set bit in a bitstring we iterate over all
            bit positions in the bitstring and right-shift the bits before using
            the binary AND operation to check if the rightmost bit is set.
            Once we encounter a bit, the iteration counter contains the index of
            the bit.
            An implementation of this scheme is shown in
            \autoref{alg:get-index}.
            \begin{algorithm}
                \inputpython{implementation/solvers/determinants.py}{111}{125}
                \caption{Function computing the index of a set bit in Slater
                determinant.
                The parameter \pyth{index_num} decides if we should find the
                first (\pyth{0}), second (\pyth{1}), or higher, set bits.}
                \label{alg:get-index}
            \end{algorithm}
            % TODO: Add the implementation of the Slater-Condon rules?


        \subsection{Diagonalization}
            Having constructed the full Hamiltonian matrix $\hamilmat \in
            \mathbb{C}^{N_s \times N_s}$ the next step is to diagonalize the
            matrix in order to get the eigenenergies $\vfg{\energy} = \diag(E_1,
            \dots, E_{N_s})$ and the eigenvectors, i.e., the coefficients for
            the eigenstates, $\vfg{C} \in \mathbb{C}^{N_s \times N_s}$.
            As stated in \autoref{chap:ci}, we restrict our attention to
            orthonormal single-particle states and we therefore need to solve
            the eigenvalue equation
            \begin{align}
                \hamilmat\vfg{C} = \vfg{E}\vfg{C}.
            \end{align}
            The Hamiltonian matrix is Hermitian and we can therefore use the
            function \pyth{np.linalg.eigh} \cite{numpy}, which uses the
            LAPACK-routines \cite{laug} \pyth{_syevd} and \pyth{_heevd} for
            symmetrc and Hermitian matrices respectively, to solve the
            eigenvalue equation.
            This will yield the full spectrum of $\hamilmat$ and will often
            prove a limiting factor in terms of computational complexity as the
            number of FLOPS required to solve this equation scales as
            $\mathcal{O}(N_s^3)$.

            As an alternative to the full spectrum we can use a sparse
            eigenvalue solver.
            We use the function \pyth{scipy.sparse.linalg.eigsh} from SymPy
            \cite{sympy} which is a wrapper around the ARPACK routines SSEUPD
            and DSEUPD \cite{arpack} implementing the Implictly Restarted
            Lanczos Method with a theortical complexity of $\mathcal{O}(N_s^2)$.
            This lets us specify how many eigenpairs $k$ we wish to compute,
            which is then found iteratively.

            The eigensolvers given by NumPy \cite{numpy} and SciPy \cite{sympy}
            sorts the eigenvalues in an ascending order with the eigenvectors
            sorted in the same fashion, and with the eigenvectors unitary.
            This means that the ground state energy is found as the first
            element of the eigenvalues.

        \subsection{One-body density matrix}
            Having diagonalized the Hamiltonian matrix we can compute the one-body
            density matrix of the system.
            For a given eigenstate $\ket{\Psi_I}$ we compute the one-body
            density matrix by
            \begin{align}
                {\rho_I}^{q}_{p}
                &= \bra{\Psi_I}\ccr{p}\can{q}\ket{\Psi_I}
                = C_{JI}^{*}C_{KI}\bra{\slat_J}\ccr{p}\can{q}\ket{\slat_K}.
                \label{eq:ci-one-body-density}
            \end{align}
            As matrix elements of the one-body density matrix is given by a pair
            of creation and annihilation operators we can use the Slater-Condon
            rules for one-body operators to evaluate the overlap.
            This results in virtually the same implementation as for the
            one-body Hamiltonian, but with a new one-body operator given by the
            coefficient vector $\vfg{c}_I$ for a specific eigenstate
            $\ket{\Psi_I}$.
            Do note that $\vfg{c}_I \in \mathbb{C}^{N_s}$ and that the indices
            into this vector is given by the same indices as for the Slater
            determinants, unlike the single-particle indices used for the
            one-body density matrix and the one-body Hamiltonian.

        \subsection{Time-evolution}
            Having solved the ground state problem, we move on to the dynamics
            of the configuration interaction method.
            Choosing an initial state with a given coefficient vector
            $\vfg{c}(0) \in \mathbb{C}^{N_s}$, either from the ground state
            problem or from some other method, we prooceed to solve the
            differential equation demonstrated in \autoref{eq:tdci}.
            In atomic units this corresponds to solving
            \begin{align}
                \dot{\vfg{c}}(t) = -i\hamilmat(t)\vfg{c}(t).
            \end{align}
            Having already set up the framework for the numerical integrators as
            described in \autoref{sec:numerical-integration}, our task is to
            construct the time-dependent Hamiltonian matrix.
            In general we can construct the time-dependent matrix elements from
            \begin{align}
                \hamilten_{IJ}(t)
                &=
                \oneten^{p}_{q}(t)
                \bra{\slat_I}\ccr{p}\can{q}\ket{\slat_J}
                + \frac{1}{4}\twoten^{pq}_{rs}(t)
                \bra{\slat_I}\ccr{p}\ccr{q}\can{s}\can{r}\ket{\slat_J}.
            \end{align}
            and re-use the Slater-Condon rules to evaluate the one- and two-body
            operators.
            Our implementation does programmatically support a time-dependent
            two-body operator, but this is not something that we will use.
            Therefore, by only including time-dependent one-body operators, an
            optimization is to store two copies of the full Hamiltonian
            matrix,\footnote{%
                This might seem a little odd as we've already argued at length
                of how the Hamiltonian matrix is the bottleneck of the
                implementation, but remember that our focus is on the dynamics
                of quantum-mechanical systems and we are therefore quite limited
                in the size of the systems we can explore.
                This means that we will seldom look at very large systems and we
                can often store the full Hamiltonian matrix, and copies, in
                memory.
            }
            and only re-compute the time-dependent one-body contributions.
            We define the two sets of matrix elements for the Hamiltonian matrix
            by
            \begin{gather}
                (\hamil_1)_{IJ}(t)
                \equiv
                \mel{\slat_I}{\onehamil(t)}{\slat_J}, \\
                (\hamil_2)_{IJ}(t)
                \equiv
                \mel{\slat_I}{\twohamil(t)}{\slat_J}.
            \end{gather}
            Setting $\twohamil(t) = \twohamil$ we now compute the Hamiltonian
            matrix from
            \begin{align}
                \hamilmat(t)
                = \hamilmat_1(t) + \hamilmat_2,
            \end{align}
            where we only construct a new $\hamilmat_1(t)$ -- using the
            Slater-Condon rules for the one-body operator -- at every timestep.

        \subsection{Time-dependent energy}
            For a time-evolved state $\ket{\Psi(t)}$ with a time-evolved
            Hamiltonian $\hamil(t)$, we can compute the energy of the state at a
            certain time $t$ by
            \begin{align}
                E(t) = \frac{
                    \mel{\Psi(t)}{\hamil(t)}{\Psi(t)}
                }{
                    \braket{\Psi(t)}
                },
            \end{align}
            where we've included an explicit normalization due to potential
            drift in the coefficients from the time-evolution using numerical
            integrators.
            Expanding the time-evolved state in the static basis of Slater
            determinants with time-dependent coefficients, $\vfg{c}(t)$, we find
            the time-dependent energy to be
            \begin{align}
                E(t)
                &=
                \frac{
                    c^{*}_I(t)\mel{\slat_I}{\hamil(t)}{\slat_J}c_J(t)
                }{
                    c^{*}_I(t)c_I(t)
                }
                = \frac{
                    \vfg{c}^{\dagger}(t)\hamilmat(t)\vfg{c}(t)
                }{
                    \vfg{c}^{\dagger}(t)\vfg{c}(t)
                }.
            \end{align}


        \subsection{Time-dependent overlap}
            We compute the time-dependent overlap by
            \begin{align}
                P(t)
                =
                \frac{
                    \abs{\braket{\Psi(t)}{\Psi(0)}}^2
                }{
                    \braket{\Psi(t)}\braket{\Psi(0)}
                }
                = \frac{
                    \abs{\vfg{c}^{\dagger}(t)\vfg{c}(0)}^2
                }{
                    \abs{\vfg{c}(t)}^2
                    \abs{\vfg{c}(0)}^2
                },
            \end{align}
            where we again include an explicit normalization term in case of
            drift in the normalization due to the integrator.
            We also compute the overlap from the initial time $t = 0$.

    \section{Coupled cluster}
